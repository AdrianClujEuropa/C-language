{"filter":false,"title":"myversion.c","tooltip":"/pset4/resize/myversion.c","undoManager":{"mark":35,"position":35,"stack":[[{"start":{"row":0,"column":0},"end":{"row":134,"column":0},"action":"insert","lines":["/**"," * Copies a BMP piece by piece, just because."," */","","#include <stdio.h>","#include <stdlib.h>","","#include \"bmp.h\"","","int main(int argc, char *argv[])","{","    // ensure proper usage","    if (argc != 4)","    {","        fprintf(stderr, \"Usage: ./resize n infile outfile\\n\");","        return 1;","    }","","    // remember filenames","    int n = atoi(argv[1]);","    char *infile = argv[2];","    char *outfile = argv[3];","","    // open input file","    FILE *inptr = fopen(infile, \"r\");","    if (inptr == NULL)","    {","        fprintf(stderr, \"Could not open %s.\\n\", infile);","        return 2;","    }","","    // open output file","    FILE *outptr = fopen(outfile, \"w\");","    if (outptr == NULL)","    {","        fclose(inptr);","        fprintf(stderr, \"Could not create %s.\\n\", outfile);","        return 3;","    }","","    // read infile's BITMAPFILEHEADER","    BITMAPFILEHEADER bf;","    fread(&bf, sizeof(BITMAPFILEHEADER), 1, inptr);","","    // read infile's BITMAPINFOHEADER","    BITMAPINFOHEADER bi;","    fread(&bi, sizeof(BITMAPINFOHEADER), 1, inptr);","","","    // ensure infile is (likely) a 24-bit uncompressed BMP 4.0","    if (bf.bfType != 0x4d42 || bf.bfOffBits != 54 || bi.biSize != 40 ||","        bi.biBitCount != 24 || bi.biCompression != 0)","    {","        fclose(outptr);","        fclose(inptr);","        fprintf(stderr, \"Unsupported file format.\\n\");","        return 4;","    }","","","    bi.biWidth *= n;","    int padding = (4 - (bi.biWidth * sizeof(RGBTRIPLE)) % 4) % 4;","    bi.biHeight *= n;","    bi.biSizeImage = ((sizeof(RGBTRIPLE) * bi.biWidth) + padding) *abs(bi.biHeight);","    bf.bfSize = bi.biSizeImage + sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER);","","    // write outfile's BITMAPFILEHEADER","    fwrite(&bf, sizeof(BITMAPFILEHEADER), 1, outptr);","","    // write outfile's BITMAPINFOHEADER","    fwrite(&bi, sizeof(BITMAPINFOHEADER), 1, outptr);","","    // iterate over infile's scanlines","    for (int i = 0, biHeight = abs(bi.biHeight)/n; i < biHeight; i++)","    {","        for (int z=0; z<n-1; z++)","        {","            // iterate over pixels in scanline","            for (int j = 0; j < bi.biWidth/n; j++)","            {","                // temporary storage","                RGBTRIPLE triple;","","                // read RGB triple from infile","                fread(&triple, sizeof(RGBTRIPLE), 1, inptr);","","                //what?","","                // write RGB triple to outfile","                fwrite(&triple, sizeof(RGBTRIPLE), n, outptr);","            }","","            // then add it back (to demonstrate how)","            for (int k = 0; k < padding; k++)","            {","                fputc(0x00, outptr);","            }","","            fseek(inptr, -bi.biWidth/n, SEEK_CUR);","","        }","","        for (int j = 0; j < bi.biWidth/n; j++)","            {","                // temporary storage","                RGBTRIPLE triple;","","                // read RGB triple from infile","                fread(&triple, sizeof(RGBTRIPLE), 1, inptr);","","                //what?","","                // write RGB triple to outfile","                fwrite(&triple, sizeof(RGBTRIPLE), n, outptr);","            }","","            for (int k = 0; k < padding; k++)","            {","                fputc(0x00, outptr);","            }","","         // skip over padding, if any","            fseek(inptr, padding, SEEK_CUR);","    }","","    // close infile","    fclose(inptr);","","    // close outfile","    fclose(outptr);","","    // success","    return 0;","}",""],"id":1}],[{"start":{"row":19,"column":26},"end":{"row":20,"column":0},"action":"insert","lines":["",""],"id":2},{"start":{"row":20,"column":0},"end":{"row":20,"column":4},"action":"insert","lines":["    "]}],[{"start":{"row":20,"column":4},"end":{"row":21,"column":0},"action":"insert","lines":["",""],"id":3},{"start":{"row":21,"column":0},"end":{"row":21,"column":4},"action":"insert","lines":["    "]}],[{"start":{"row":20,"column":4},"end":{"row":24,"column":5},"action":"insert","lines":["    if (scale_size < 1 || scale_size > 100)","    {","        printf(\"Scale must be between 1 and 100\\n\");","        return 1;","    }"],"id":4}],[{"start":{"row":20,"column":4},"end":{"row":20,"column":8},"action":"remove","lines":["    "],"id":5}],[{"start":{"row":20,"column":8},"end":{"row":20,"column":18},"action":"remove","lines":["scale_size"],"id":6},{"start":{"row":20,"column":8},"end":{"row":20,"column":9},"action":"insert","lines":["n"]}],[{"start":{"row":20,"column":17},"end":{"row":20,"column":27},"action":"remove","lines":["scale_size"],"id":7},{"start":{"row":20,"column":17},"end":{"row":20,"column":18},"action":"insert","lines":["n"]}],[{"start":{"row":66,"column":3},"end":{"row":71,"column":0},"action":"remove","lines":[" bi.biWidth *= n;","    int padding = (4 - (bi.biWidth * sizeof(RGBTRIPLE)) % 4) % 4;","    bi.biHeight *= n;","    bi.biSizeImage = ((sizeof(RGBTRIPLE) * bi.biWidth) + padding) *abs(bi.biHeight);","    bf.bfSize = bi.biSizeImage + sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER);",""],"id":8}],[{"start":{"row":66,"column":3},"end":{"row":81,"column":0},"action":"insert","lines":["// create outfile's BITMAPFILEHEADER and BITMAPINFOHEADER","    BITMAPFILEHEADER out_bf = bf;","    BITMAPINFOHEADER out_bi = bi;","","    // rescale the new dimension for the outfile","    out_bi.biWidth *= scale_size;","    out_bi.biHeight *= scale_size;","","    // determine padding for scanlines of both infile and outfile","    int in_padding =  (4 - (bi.biWidth * sizeof(RGBTRIPLE)) % 4) % 4;","    int out_padding = (4 - (out_bi.biWidth * sizeof(RGBTRIPLE)) % 4) % 4;","","    // determine the outfile biSizeImage and bfSize (biSizeImage + 54 bytes header files)","    out_bi.biSizeImage = abs(out_bi.biHeight) * (out_bi.biWidth * sizeof(RGBTRIPLE) + out_padding);","    out_bf.bfSize = (out_bi.biSizeImage + 54);",""],"id":9}],[{"start":{"row":71,"column":22},"end":{"row":71,"column":32},"action":"remove","lines":["scale_size"],"id":10},{"start":{"row":71,"column":22},"end":{"row":71,"column":23},"action":"insert","lines":["n"]}],[{"start":{"row":72,"column":23},"end":{"row":72,"column":33},"action":"remove","lines":["scale_size"],"id":11},{"start":{"row":72,"column":23},"end":{"row":72,"column":24},"action":"insert","lines":["n"]}],[{"start":{"row":89,"column":48},"end":{"row":89,"column":49},"action":"remove","lines":["n"],"id":12}],[{"start":{"row":89,"column":47},"end":{"row":89,"column":48},"action":"remove","lines":["/"],"id":13}],[{"start":{"row":91,"column":26},"end":{"row":91,"column":27},"action":"remove","lines":["1"],"id":20}],[{"start":{"row":91,"column":25},"end":{"row":91,"column":26},"action":"remove","lines":["-"],"id":21}],[{"start":{"row":92,"column":9},"end":{"row":93,"column":0},"action":"insert","lines":["",""],"id":22},{"start":{"row":93,"column":0},"end":{"row":93,"column":12},"action":"insert","lines":["            "]}],[{"start":{"row":93,"column":12},"end":{"row":95,"column":0},"action":"insert","lines":["// set pointer to beginning of line","            fseek(inptr, 54 + (bi.biWidth * 3 + in_padding) * i, SEEK_SET);",""],"id":23}],[{"start":{"row":117,"column":0},"end":{"row":118,"column":0},"action":"remove","lines":["            fseek(inptr, -bi.biWidth/n, SEEK_CUR);",""],"id":24}],[{"start":{"row":120,"column":8},"end":{"row":140,"column":44},"action":"remove","lines":["for (int j = 0; j < bi.biWidth/n; j++)","            {","                // temporary storage","                RGBTRIPLE triple;","","                // read RGB triple from infile","                fread(&triple, sizeof(RGBTRIPLE), 1, inptr);","","                //what?","","                // write RGB triple to outfile","                fwrite(&triple, sizeof(RGBTRIPLE), n, outptr);","            }","","            for (int k = 0; k < padding; k++)","            {","                fputc(0x00, outptr);","            }","","         // skip over padding, if any","            fseek(inptr, padding, SEEK_CUR);"],"id":25}],[{"start":{"row":120,"column":4},"end":{"row":120,"column":8},"action":"remove","lines":["    "],"id":26}],[{"start":{"row":120,"column":0},"end":{"row":120,"column":4},"action":"remove","lines":["    "],"id":27}],[{"start":{"row":119,"column":0},"end":{"row":120,"column":0},"action":"remove","lines":["",""],"id":28}],[{"start":{"row":118,"column":9},"end":{"row":119,"column":0},"action":"remove","lines":["",""],"id":29}],[{"start":{"row":116,"column":0},"end":{"row":117,"column":0},"action":"remove","lines":["",""],"id":30}],[{"start":{"row":115,"column":13},"end":{"row":116,"column":0},"action":"remove","lines":["",""],"id":31}],[{"start":{"row":104,"column":0},"end":{"row":105,"column":23},"action":"remove","lines":["","                //what?"],"id":32}],[{"start":{"row":104,"column":0},"end":{"row":105,"column":0},"action":"remove","lines":["",""],"id":33}],[{"start":{"row":86,"column":12},"end":{"row":86,"column":14},"action":"remove","lines":["bi"],"id":34},{"start":{"row":86,"column":12},"end":{"row":86,"column":18},"action":"insert","lines":["out_bi"]}],[{"start":{"row":83,"column":12},"end":{"row":83,"column":14},"action":"remove","lines":["bf"],"id":35},{"start":{"row":83,"column":12},"end":{"row":83,"column":18},"action":"insert","lines":["out_bf"]}],[{"start":{"row":25,"column":0},"end":{"row":25,"column":4},"action":"remove","lines":["    "],"id":36}],[{"start":{"row":0,"column":0},"end":{"row":126,"column":0},"action":"remove","lines":["/**"," * Copies a BMP piece by piece, just because."," */","","#include <stdio.h>","#include <stdlib.h>","","#include \"bmp.h\"","","int main(int argc, char *argv[])","{","    // ensure proper usage","    if (argc != 4)","    {","        fprintf(stderr, \"Usage: ./resize n infile outfile\\n\");","        return 1;","    }","","    // remember filenames","    int n = atoi(argv[1]);","    if (n < 1 || n > 100)","    {","        printf(\"Scale must be between 1 and 100\\n\");","        return 1;","    }","","    char *infile = argv[2];","    char *outfile = argv[3];","","    // open input file","    FILE *inptr = fopen(infile, \"r\");","    if (inptr == NULL)","    {","        fprintf(stderr, \"Could not open %s.\\n\", infile);","        return 2;","    }","","    // open output file","    FILE *outptr = fopen(outfile, \"w\");","    if (outptr == NULL)","    {","        fclose(inptr);","        fprintf(stderr, \"Could not create %s.\\n\", outfile);","        return 3;","    }","","    // read infile's BITMAPFILEHEADER","    BITMAPFILEHEADER bf;","    fread(&bf, sizeof(BITMAPFILEHEADER), 1, inptr);","","    // read infile's BITMAPINFOHEADER","    BITMAPINFOHEADER bi;","    fread(&bi, sizeof(BITMAPINFOHEADER), 1, inptr);","","","    // ensure infile is (likely) a 24-bit uncompressed BMP 4.0","    if (bf.bfType != 0x4d42 || bf.bfOffBits != 54 || bi.biSize != 40 ||","        bi.biBitCount != 24 || bi.biCompression != 0)","    {","        fclose(outptr);","        fclose(inptr);","        fprintf(stderr, \"Unsupported file format.\\n\");","        return 4;","    }","","","   // create outfile's BITMAPFILEHEADER and BITMAPINFOHEADER","    BITMAPFILEHEADER out_bf = bf;","    BITMAPINFOHEADER out_bi = bi;","","    // rescale the new dimension for the outfile","    out_bi.biWidth *= n;","    out_bi.biHeight *= n;","","    // determine padding for scanlines of both infile and outfile","    int in_padding =  (4 - (bi.biWidth * sizeof(RGBTRIPLE)) % 4) % 4;","    int out_padding = (4 - (out_bi.biWidth * sizeof(RGBTRIPLE)) % 4) % 4;","","    // determine the outfile biSizeImage and bfSize (biSizeImage + 54 bytes header files)","    out_bi.biSizeImage = abs(out_bi.biHeight) * (out_bi.biWidth * sizeof(RGBTRIPLE) + out_padding);","    out_bf.bfSize = (out_bi.biSizeImage + 54);","","    // write outfile's BITMAPFILEHEADER","    fwrite(&out_bf, sizeof(BITMAPFILEHEADER), 1, outptr);","","    // write outfile's BITMAPINFOHEADER","    fwrite(&out_bi, sizeof(BITMAPINFOHEADER), 1, outptr);","","    // iterate over infile's scanlines","    for (int i = 0, biHeight = abs(bi.biHeight); i < biHeight; i++)","    {","        for (int z=0; z<n; z++)","        {","            // set pointer to beginning of line","            fseek(inptr, 54 + (bi.biWidth * 3 + in_padding) * i, SEEK_SET);","","            // iterate over pixels in scanline","            for (int j = 0; j < bi.biWidth/n; j++)","            {","                // temporary storage","                RGBTRIPLE triple;","","                // read RGB triple from infile","                fread(&triple, sizeof(RGBTRIPLE), 1, inptr);","","                // write RGB triple to outfile","                fwrite(&triple, sizeof(RGBTRIPLE), n, outptr);","            }","","            // then add it back (to demonstrate how)","            for (int k = 0; k < padding; k++)","            {","                fputc(0x00, outptr);","            }","        }","    }","","    // close infile","    fclose(inptr);","","    // close outfile","    fclose(outptr);","","    // success","    return 0;","}",""],"id":37}],[{"start":{"row":0,"column":0},"end":{"row":126,"column":0},"action":"insert","lines":["/**"," * Copies a BMP piece by piece, just because."," */","","#include <stdio.h>","#include <stdlib.h>","","#include \"bmp.h\"","","int main(int argc, char *argv[])","{","    // ensure proper usage","    if (argc != 4)","    {","        fprintf(stderr, \"Usage: ./resize n infile outfile\\n\");","        return 1;","    }","","    // remember filenames","    int n = atoi(argv[1]);","    if (n < 1 || n > 100)","    {","        printf(\"Scale must be between 1 and 100\\n\");","        return 1;","    }","","    char *infile = argv[2];","    char *outfile = argv[3];","","    // open input file","    FILE *inptr = fopen(infile, \"r\");","    if (inptr == NULL)","    {","        fprintf(stderr, \"Could not open %s.\\n\", infile);","        return 2;","    }","","    // open output file","    FILE *outptr = fopen(outfile, \"w\");","    if (outptr == NULL)","    {","        fclose(inptr);","        fprintf(stderr, \"Could not create %s.\\n\", outfile);","        return 3;","    }","","    // read infile's BITMAPFILEHEADER","    BITMAPFILEHEADER bf;","    fread(&bf, sizeof(BITMAPFILEHEADER), 1, inptr);","","    // read infile's BITMAPINFOHEADER","    BITMAPINFOHEADER bi;","    fread(&bi, sizeof(BITMAPINFOHEADER), 1, inptr);","","","    // ensure infile is (likely) a 24-bit uncompressed BMP 4.0","    if (bf.bfType != 0x4d42 || bf.bfOffBits != 54 || bi.biSize != 40 ||","        bi.biBitCount != 24 || bi.biCompression != 0)","    {","        fclose(outptr);","        fclose(inptr);","        fprintf(stderr, \"Unsupported file format.\\n\");","        return 4;","    }","","","   // create outfile's BITMAPFILEHEADER and BITMAPINFOHEADER","    BITMAPFILEHEADER out_bf = bf;","    BITMAPINFOHEADER out_bi = bi;","","    // rescale the new dimension for the outfile","    out_bi.biWidth *= n;","    out_bi.biHeight *= n;","","    // determine padding for scanlines of both infile and outfile","    int in_padding =  (4 - (bi.biWidth * sizeof(RGBTRIPLE)) % 4) % 4;","    int out_padding = (4 - (out_bi.biWidth * sizeof(RGBTRIPLE)) % 4) % 4;","","    // determine the outfile biSizeImage and bfSize (biSizeImage + 54 bytes header files)","    out_bi.biSizeImage = abs(out_bi.biHeight) * (out_bi.biWidth * sizeof(RGBTRIPLE) + out_padding);","    out_bf.bfSize = (out_bi.biSizeImage + 54);","","    // write outfile's BITMAPFILEHEADER","    fwrite(&out_bf, sizeof(BITMAPFILEHEADER), 1, outptr);","","    // write outfile's BITMAPINFOHEADER","    fwrite(&out_bi, sizeof(BITMAPINFOHEADER), 1, outptr);","","    // iterate over infile's scanlines","    for (int i = 0, biHeight = abs(bi.biHeight); i < biHeight; i++)","    {","        for (int z=0; z<n; z++)","        {","            // set pointer to beginning of line","            fseek(inptr, 54 + (bi.biWidth * 3 + in_padding) * i, SEEK_SET);","","            // iterate over pixels in scanline","            for (int j = 0; j < bi.biWidth/n; j++)","            {","                // temporary storage","                RGBTRIPLE triple;","","                // read RGB triple from infile","                fread(&triple, sizeof(RGBTRIPLE), 1, inptr);","","                // write RGB triple to outfile","                fwrite(&triple, sizeof(RGBTRIPLE), n, outptr);","            }","","            // then add it back (to demonstrate how)","            for (int k = 0; k < out_padding; k++)","            {","                fputc(0x00, outptr);","            }","        }","    }","","    // close infile","    fclose(inptr);","","    // close outfile","    fclose(outptr);","","    // success","    return 0;","}",""],"id":38}],[{"start":{"row":106,"column":49},"end":{"row":106,"column":50},"action":"insert","lines":["*"],"id":39}],[{"start":{"row":106,"column":50},"end":{"row":106,"column":51},"action":"insert","lines":["n"],"id":40}],[{"start":{"row":106,"column":53},"end":{"row":106,"column":54},"action":"remove","lines":["n"],"id":41}],[{"start":{"row":106,"column":53},"end":{"row":106,"column":54},"action":"insert","lines":["1"],"id":42}],[{"start":{"row":0,"column":0},"end":{"row":126,"column":0},"action":"remove","lines":["/**"," * Copies a BMP piece by piece, just because."," */","","#include <stdio.h>","#include <stdlib.h>","","#include \"bmp.h\"","","int main(int argc, char *argv[])","{","    // ensure proper usage","    if (argc != 4)","    {","        fprintf(stderr, \"Usage: ./resize n infile outfile\\n\");","        return 1;","    }","","    // remember filenames","    int n = atoi(argv[1]);","    if (n < 1 || n > 100)","    {","        printf(\"Scale must be between 1 and 100\\n\");","        return 1;","    }","","    char *infile = argv[2];","    char *outfile = argv[3];","","    // open input file","    FILE *inptr = fopen(infile, \"r\");","    if (inptr == NULL)","    {","        fprintf(stderr, \"Could not open %s.\\n\", infile);","        return 2;","    }","","    // open output file","    FILE *outptr = fopen(outfile, \"w\");","    if (outptr == NULL)","    {","        fclose(inptr);","        fprintf(stderr, \"Could not create %s.\\n\", outfile);","        return 3;","    }","","    // read infile's BITMAPFILEHEADER","    BITMAPFILEHEADER bf;","    fread(&bf, sizeof(BITMAPFILEHEADER), 1, inptr);","","    // read infile's BITMAPINFOHEADER","    BITMAPINFOHEADER bi;","    fread(&bi, sizeof(BITMAPINFOHEADER), 1, inptr);","","","    // ensure infile is (likely) a 24-bit uncompressed BMP 4.0","    if (bf.bfType != 0x4d42 || bf.bfOffBits != 54 || bi.biSize != 40 ||","        bi.biBitCount != 24 || bi.biCompression != 0)","    {","        fclose(outptr);","        fclose(inptr);","        fprintf(stderr, \"Unsupported file format.\\n\");","        return 4;","    }","","","   // create outfile's BITMAPFILEHEADER and BITMAPINFOHEADER","    BITMAPFILEHEADER out_bf = bf;","    BITMAPINFOHEADER out_bi = bi;","","    // rescale the new dimension for the outfile","    out_bi.biWidth *= n;","    out_bi.biHeight *= n;","","    // determine padding for scanlines of both infile and outfile","    int in_padding =  (4 - (bi.biWidth * sizeof(RGBTRIPLE)) % 4) % 4;","    int out_padding = (4 - (out_bi.biWidth * sizeof(RGBTRIPLE)) % 4) % 4;","","    // determine the outfile biSizeImage and bfSize (biSizeImage + 54 bytes header files)","    out_bi.biSizeImage = abs(out_bi.biHeight) * (out_bi.biWidth * sizeof(RGBTRIPLE) + out_padding);","    out_bf.bfSize = (out_bi.biSizeImage + 54);","","    // write outfile's BITMAPFILEHEADER","    fwrite(&out_bf, sizeof(BITMAPFILEHEADER), 1, outptr);","","    // write outfile's BITMAPINFOHEADER","    fwrite(&out_bi, sizeof(BITMAPINFOHEADER), 1, outptr);","","    // iterate over infile's scanlines","    for (int i = 0, biHeight = abs(bi.biHeight); i < biHeight; i++)","    {","        for (int z=0; z<n; z++)","        {","            // set pointer to beginning of line","            fseek(inptr, 54 + (bi.biWidth * 3 + in_padding) * i, SEEK_SET);","","            // iterate over pixels in scanline","            for (int j = 0; j < bi.biWidth/n; j++)","            {","                // temporary storage","                RGBTRIPLE triple;","","                // read RGB triple from infile","                fread(&triple, sizeof(RGBTRIPLE), 1, inptr);","","                // write RGB triple to outfile","                fwrite(&triple, sizeof(RGBTRIPLE)*n, 1, outptr);","            }","","            // then add it back (to demonstrate how)","            for (int k = 0; k < out_padding; k++)","            {","                fputc(0x00, outptr);","            }","        }","    }","","    // close infile","    fclose(inptr);","","    // close outfile","    fclose(outptr);","","    // success","    return 0;","}",""],"id":43}]]},"ace":{"folds":[],"scrolltop":795,"scrollleft":3,"selection":{"start":{"row":5,"column":19},"end":{"row":5,"column":19},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":48,"state":"start","mode":"ace/mode/c_cpp"}},"timestamp":1511741931045,"hash":"d7ac45de30d048108d12560a59a7718032ef2d13"}